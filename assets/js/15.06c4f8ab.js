(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{289:function(e,t,a){"use strict";a.r(t);var n=a(3),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"react基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react基础"}},[e._v("#")]),e._v(" react基础")]),e._v(" "),a("h2",{attrs:{id:"基础内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础内容"}},[e._v("#")]),e._v(" 基础内容")]),e._v(" "),a("ul",[a("li",[e._v("环境基础")]),e._v(" "),a("li",[e._v("项目架构")]),e._v(" "),a("li",[e._v("组件化思维")]),e._v(" "),a("li",[e._v("jsx语法")]),e._v(" "),a("li",[e._v("react在chrome上的调试")]),e._v(" "),a("li",[e._v("虚拟dom")]),e._v(" "),a("li",[e._v("生命周期")])]),e._v(" "),a("h3",{attrs:{id:"环境基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#环境基础"}},[e._v("#")]),e._v(" 环境基础")]),e._v(" "),a("h5",{attrs:{id:"通过npm-node环境-安装cnpm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过npm-node环境-安装cnpm"}},[e._v("#")]),e._v(" 通过npm node环境(安装cnpm)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("npm install -g cnpm --registry=https://registry.npm.taobao.org\nnpm config set registry https://registry.npm.taobao.org\n")])])]),a("h2",{attrs:{id:"项目架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#项目架构"}},[e._v("#")]),e._v(" 项目架构")]),e._v(" "),a("p",[e._v("快速构建React开发环境")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ cnpm install -g create-react-app\n$ create-react-app my-app\n$ cd my-app/\n$ npm start\n")])])]),a("h3",{attrs:{id:"常用目录结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用目录结构"}},[e._v("#")]),e._v(" 常用目录结构")]),e._v(" "),a("h6",{attrs:{id:"基本目录说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本目录说明"}},[e._v("#")]),e._v(" 基本目录说明")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("├── README.md //关于项目的说明文件。\n├── package.json //node的包文件，关于项目的一些介绍及一些项目的指令等。\n├── config //配置文件\n│   ├── webpack.base.js //通用配置\n│   ├── webpack.prod.js //生产环境配置\n│   └── webpack.dev.js //开发环境配置\n├── public //公共资源\n│   ├── favicon.ico //项目图标\n│   ├── manifest.json//用于指定应用的显示名称、图标、应用入口文件地址及需要使用的设备权限等信息\n│   └── index.html\n├── src\n│   ├── App.css\n│   ├── App.js\n│   ├── App.test.js //项目测试文件\n│   ├── index.css\n│   ├── index.js //程序入口文件\n│   ├── logo.svg\n│   └── serviceWorker.js //常用于生产环境做资源缓存\n└── yarn.lock\n")])])]),a("h3",{attrs:{id:"组件化思维"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件化思维"}},[e._v("#")]),e._v(" 组件化思维")]),e._v(" "),a("blockquote",[a("p",[e._v("react组件化是把界面不断分解,分解为多个个小控件的相互组合,到不能再分割为止.")])]),e._v(" "),a("h5",{attrs:{id:"组件化本质"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件化本质"}},[e._v("#")]),e._v(" 组件化本质:")]),e._v(" "),a("pre",[a("code",[e._v("组件化本质是面向对象的设计思想.组件化可以对应于 一个类，每个类都对外输出不变的接⼝，只要接⼝不变，类与类间的通讯可以根据接⼝进行，由此不同组件间的耦合度就降低了。\n优点:提高了组件的可用性和降低了单个组件的复杂度\n")])]),e._v(" "),a("h3",{attrs:{id:"react-jsx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-jsx"}},[e._v("#")]),e._v(" React jsx")]),e._v(" "),a("pre",[a("code",[e._v("react使用jsx来替代常规javascript\n")])]),e._v(" "),a("blockquote",[a("p",[e._v("优点:")])]),e._v(" "),a("ul",[a("li",[e._v("JSX执行更快,在编译为javascript代码后进行了优化")]),e._v(" "),a("li",[e._v("它是类型安全,在编译过成功就能发现错误")]),e._v(" "),a("li",[e._v("使用Jsx编写模板更加简单快速")])]),e._v(" "),a("h5",{attrs:{id:"常用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用"}},[e._v("#")]),e._v(" 常用")]),e._v(" "),a("blockquote",[a("p",[e._v("类html(dom及属性)")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ReactDOM.render(\n    <div>\n    <h2>欢迎学习 React</h2>\n    <p data-myattribute = \"somevalue\">这是一个很不错的 JavaScript 库!</p>\n    </div>\n    ,\n    document.getElementById('example')\n);\n")])])]),a("blockquote",[a("p",[e._v("js表达式\n可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中。\n(js表达式,三目运算,样式,注释,数组)")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var myStyle = {\n    fontSize: 100,\n    color: '#FF0000'\n};\nReactDOM.render(\n    <div>\n      <h1>{1+1}</h1>\n      <h2>{i == 1 ? 'True!' : 'False'}</h2>\n      <h3 style = {myStyle}>菜鸟教程</h3>,\n        {/*注释...*/}\n        {arr.map((item,index)=>{\n            <p>{{item.name}}</p>\n        }}\n    </div>\n    ,\n    document.getElementById('app')\n);\n")])])]),a("h3",{attrs:{id:"react在dom上的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react在dom上的使用"}},[e._v("#")]),e._v(" React在DOM上的使用")]),e._v(" "),a("ul",[a("li",[e._v("render()")]),e._v(" "),a("li",[e._v("unmountComponentAtNode()")]),e._v(" "),a("li",[e._v("findDomNode")])]),e._v(" "),a("blockquote",[a("p",[e._v("render()")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ReactDOM.render(\n  element,\n  container,\n  [callback]\n)\n    ReactDOM.render(element,document.getElementById('app')\n)\n")])])]),a("blockquote",[a("p",[e._v("unmountComponentAtNode(container)卸载组件")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ReactDOM.unmountComponentAtNode(container)\n//移除已挂载的React组件，清除它的事件处理器和state\n有组件被卸载返回true,没有组件被卸载返回false\n\n")])])]),a("blockquote",[a("p",[e._v("findDOMNode(component)")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("return:　\n返回对应浏览器生成的Dom //已挂载\nnull //无\n//作用:从DOM中读取值(表单的值,计算dom元素尺寸)\n")])])]),a("blockquote",[a("p",[e._v("react ref属性")])]),e._v(" "),a("h6",{attrs:{id:"react提供的ref属性-表示对组件真正实例的引用也就是reactdom-render-返回的组件实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react提供的ref属性-表示对组件真正实例的引用也就是reactdom-render-返回的组件实例"}},[e._v("#")]),e._v(" react提供的ref属性,表示对组件真正实例的引用也就是ReactDOM.render()返回的组件实例;")]),e._v(" "),a("ul",[a("li",[e._v("ReactDOM.render()渲染组件时返回的是组件实例；")]),e._v(" "),a("li",[e._v("ref属性只能在当前组件被访问\n组件上和dom节点都可以使用")]),e._v(" "),a("li",[e._v("ref 回调会在componentDidMount 或 componentDidUpdate 这些生命周期回调之前执行。")]),e._v(" "),a("li")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 给 h5 元素设置 ref <a ref=\"update\">更新</a>后，可以拿到它的真实 dom<a>更新</a>。\n// 给组件设置ref<Child ref = 'child'/>后，拿到的是组件的实例(上图中的Constructor)\ncomponentDidMount(){\n    console.log(this.refs.child); // 访问挂载在组件上ref\n    console.log(this.refs.child.refs.update); // 访问挂载在dom元素上的ref\n  }\n")])])]),a("p",[a("strong",[e._v("this.refs")]),e._v(" 和 "),a("strong",[e._v("ReactDOM.findDOMNode")]),e._v("的区别")]),e._v(" "),a("ul",[a("li",[e._v("ref添加到Compoennt上获取的是Compoennt实例，添加到原生HTML上获取的是DOM；")]),e._v(" "),a("li",[e._v("ReactDOM.findDOMNode，当参数是DOM，返回值就是该DOM；当参数是Component获取的是该Component render方法中的DOM")]),e._v(" "),a("li",[e._v("二者主要区别在ref绑定在组件上的时候，this.refs获取到的是组件实例，ReactDOM.findDOMNode获取到的是dom节点。")])]),e._v(" "),a("h3",{attrs:{id:"react在chrome上的调试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react在chrome上的调试"}},[e._v("#")]),e._v(" react在chrome上的调试")]),e._v(" "),a("ol",[a("li",[e._v("去github 下载react-devtool,")]),e._v(" "),a("li",[e._v("进入react-devtools-master文件夹,用npm安装")]),e._v(" "),a("li",[e._v("安装依赖成功后,打包扩展程序")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("npm run build:extension:chrome\n")])])]),a("ol",{attrs:{start:"4"}},[a("li",[e._v("生成一个新的文件夹，react-devtools -> shells -> chrome -> build -> unpacked文件夹")]),e._v(" "),a("li",[e._v("打开chrome扩展程序chrome://extensions/，加载已解压的扩展程序(unpacked)，")])]),e._v(" "),a("h3",{attrs:{id:"react-虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-虚拟dom"}},[e._v("#")]),e._v(" react 虚拟dom")]),e._v(" "),a("blockquote",[a("p",[e._v("原理 虚拟dom的diff算法")])]),e._v(" "),a("ol",[a("li",[e._v("React 通过 updateDepth 对 Virtual DOM 树进行层级控制，同一个父节点下的所有子节点。")]),e._v(" "),a("li",[e._v("跨层级操作:React 只会简单的考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作。")]),e._v(" "),a("li",[e._v("同一层级:，React diff提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_允许开发者对同一层级的同组子节点，添加唯一 key 进行区分(NODE（删除）。")]),e._v(" "),a("li",[e._v("允许开发者对同一层级的同组子节点，添加唯一 key 进行区分(优化相同节点的位置变化)")])]),e._v(" "),a("h3",{attrs:{id:"react生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react生命周期"}},[e._v("#")]),e._v(" react生命周期")]),e._v(" "),a("blockquote",[a("p",[e._v("组件初始化")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//initialization\nsetup props and state\n")])])]),a("blockquote",[a("p",[e._v("组件的挂载(Mounting)阶段")])]),e._v(" "),a("h6",{attrs:{id:"此阶段分为componentwillmount，render，componentdidmount三个时期。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#此阶段分为componentwillmount，render，componentdidmount三个时期。"}},[e._v("#")]),e._v(" 此阶段分为componentWillMount，render，componentDidMount三个时期。")]),e._v(" "),a("ul",[a("li",[e._v("componentWillMount:\n在组件挂载到DOM前调用，且只会被调用一次")]),e._v(" "),a("li",[e._v("render:\n根据组件的props和state（两者的重传递和重赋值，无论值是否有变化，都可以引起组件重新render） ，return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。")]),e._v(" "),a("li",[e._v("componentDidMount\n组件挂载到DOM后调用，且只会被调用一次")])]),e._v(" "),a("blockquote",[a("p",[e._v("组件更新(update)阶段\n造成组件重新render的情况")])]),e._v(" "),a("ol",[a("li",[e._v("父组件重新render引起子组件的重新render")])]),e._v(" "),a("ul",[a("li",[e._v("直接使用,每当父组件重新render导致的重传props，子组件将直接跟着重新渲染，无论props是否有变化。可通过shouldComponentUpdate方法优化。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class Child extends Component {\n   shouldComponentUpdate(nextProps){ // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染\n        if(nextProps.someThings === this.props.someThings){\n          return false\n        }\n    }\n    render() {\n        return <div>{this.props.someThings}</div>\n    }\n}\n")])])]),a("ul",[a("li",[e._v("在 componentWillReceiveProps方法中，将props转换成自己的state")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class Child extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            someThings: props.someThings\n        };\n    }\n    componentWillReceiveProps(nextProps) { // 父组件重传props时就会调用这个方法\n        this.setState({someThings: nextProps.someThings});\n    }\n    render() {\n        return <div>{this.state.someThings}</div>\n    }\n}\n//componentWillReceiveProps 判断props是否变化\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class Child extends Component {\n   constructor(props) {\n        super(props);\n        this.state = {\n          someThings:1\n        }\n   }\n   shouldComponentUpdate(nextStates){ // 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染\n        if(nextStates.someThings === this.state.someThings){\n          return false\n        }\n    }\n\n   handleClick = () => { // 虽然调用了setState ，但state并无变化\n        const preSomeThings = this.state.someThings\n         this.setState({\n            someThings: preSomeThings\n         })\n   }\n\n    render() {\n        return <div onClick = {this.handleClick}>{this.state.someThings}</div>\n    }\n}\n")])])]),a("p",[e._v("componentWillReceiveProps--\x3eshouldComponentUpdate--\x3ecomponentWillUpdate--\x3erender--\x3ecomponentDidUpdate")]),e._v(" "),a("h5",{attrs:{id:"shouldcomponentupdate-nextprops-nextstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate-nextprops-nextstate"}},[e._v("#")]),e._v(" shouldComponentUpdate(nextProps, nextState)")]),e._v(" "),a("pre",[a("code",[e._v("此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。\n\nps：这边也可以看出，就算componentWillReceiveProps()中执行了this.setState，更新了state，但在render前（如shouldComponentUpdate，componentWillUpdate），this.state依然指向更新前的state，不然nextState及当前组件的this.state的对比就一直是true了。\n")])]),e._v(" "),a("h5",{attrs:{id:"componentwillupdate-nextprops-nextstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentwillupdate-nextprops-nextstate"}},[e._v("#")]),e._v(" componentWillUpdate(nextProps, nextState)")]),e._v(" "),a("pre",[a("code",[e._v("此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。\n")])]),e._v(" "),a("h5",{attrs:{id:"render"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render"}},[e._v("#")]),e._v(" render")]),e._v(" "),a("pre",[a("code",[e._v("render方法在上文讲过，这边只是重新调用。\n")])]),e._v(" "),a("h5",{attrs:{id:"componentdidupdate-prevprops-prevstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentdidupdate-prevprops-prevstate"}},[e._v("#")]),e._v(" componentDidUpdate(prevProps, prevState)")]),e._v(" "),a("pre",[a("code",[e._v("此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state\n")])]),e._v(" "),a("blockquote",[a("p",[e._v("卸载阶段")])]),e._v(" "),a("h5",{attrs:{id:"componentwillunmount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentwillunmount"}},[e._v("#")]),e._v(" componentWillUnmount")]),e._v(" "),a("ul",[a("li",[e._v("此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);